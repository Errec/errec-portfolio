{"version":3,"sources":["debounce.js","throttle.js","animate-hero.js","animate-skill-items.js","animate-work-grid.js"],"names":["debounce","func","wait","options","invokeFunc","time","args","lastArgs","thisArg","lastThis","undefined","lastInvokeTime","result","apply","leadingEdge","timerId","setTimeout","timerExpired","leading","remainingWait","timeSinceLastCall","lastCallTime","timeSinceLastInvoke","maxing","Math","min","maxWait","shouldInvoke","Date","now","trailingEdge","trailing","cancel","clearTimeout","flush","debounced","isInvoking","arguments","this","TypeError","FUNC_ERROR_TEXT","Number","max","throttle","heroAnimation","rightHand","document","getElementById","leftHand","heroSection","heroYPosition","getBoundingClientRect","top","window","scrollY","TH","_getHeroPosition","e","_transformHero","currentYPosition","pageYOffset","className","addEventListener","svgHover","_showColor","target","currentTarget","baseVal","replace","regClassName","stopPropagation","_removeColor","svgUl","querySelector","RegExp","workGridAnimation","_add","a","b","workItems","getElementsByClassName","workSection","workItemsYPosition","workYPosition","zeroArr","Array","length","join","split","map","parseFloat","TW","_resetItensSize","innerWidth","reduce","gridItem","i","_transformWorkGrid","from","entry","abs","id","divSufix","indexOf","topGridItemID"],"mappings":"AAQA,QAAAA,UAAAC,EAAAC,EAAAC,GAuBA,QAAAC,GAAAC,GACA,GAAAC,GAAAC,EACAC,EAAAC,CAKA,OAHAF,GAAAE,EAAAC,OACAC,EAAAN,EACAO,EAAAX,EAAAY,MAAAL,EAAAF,GAIA,QAAAQ,GAAAT,GAMA,MAJAM,GAAAN,EAEAU,EAAAC,WAAAC,EAAAf,GAEAgB,EAAAd,EAAAC,GAAAO,EAGA,QAAAO,GAAAd,GACA,GAAAe,GAAAf,EAAAgB,EACAC,EAAAjB,EAAAM,EACAC,EAAAV,EAAAkB,CAEA,OAAAG,GAAAC,KAAAC,IAAAb,EAAAc,EAAAJ,GAAAV,EAGA,QAAAe,GAAAtB,GACA,GAAAe,GAAAf,EAAAgB,EACAC,EAAAjB,EAAAM,CAKA,OAAAD,UAAAW,GAAAD,GAAAlB,GACAkB,EAAA,GAAAG,GAAAD,GAAAI,EAGA,QAAAT,KACA,GAAAZ,GAAAuB,KAAAC,KACA,OAAAF,GAAAtB,GACAyB,EAAAzB,QAGAU,EAAAC,WAAAC,EAAAE,EAAAd,KAGA,QAAAyB,GAAAzB,GAKA,MAJAU,GAAAL,OAIAqB,GAAAxB,EACAH,EAAAC,IAEAE,EAAAE,EAAAC,OACAE,GAGA,QAAAoB,KACAtB,SAAAK,GACAkB,aAAAlB,GAEAJ,EAAA,EACAJ,EAAAc,EAAAZ,EAAAM,EAAAL,OAGA,QAAAwB,KACA,MAAAxB,UAAAK,EAAAH,EAAAkB,EAAAF,KAAAC,OAGA,QAAAM,KACA,GAAA9B,GAAAuB,KAAAC,MACAO,EAAAT,EAAAtB,EAMA,IAJAE,EAAA8B,UACA5B,EAAA6B,KACAjB,EAAAhB,EAEA+B,EAAA,CACA,GAAA1B,SAAAK,EACA,MAAAD,GAAAO,EAEA,IAAAE,EAGA,MADAR,GAAAC,WAAAC,EAAAf,GACAE,EAAAiB,GAMA,MAHAX,UAAAK,IACAA,EAAAC,WAAAC,EAAAf,IAEAU,EAlHA,GAAAL,GACAE,EACAiB,EACAd,EACAG,EACAM,EACAV,EAAA,EACAO,GAAA,EACAK,GAAA,EACAQ,GAAA,CAEA,IAAA,kBAAA9B,GACA,KAAA,IAAAsC,WAAAC,gBA0GA,OAxGAtC,GAAAuC,OAAAvC,IAAA,EACA,gBAAAC,KACAe,IAAAf,EAAAe,QACAK,EAAA,WAAApB,GACAuB,EAAAH,EAAAC,KAAAkB,IAAAD,OAAAtC,EAAAuB,UAAA,EAAAxB,GAAAwB,EACAK,EAAA,YAAA5B,KAAAA,EAAA4B,SAAAA,GAiGAI,EAAAH,OAAAA,EACAG,EAAAD,MAAAA,EACAC,ECvHA,QAAAQ,UAAA1C,EAAAC,EAAAC,GACA,GAAAe,IAAA,EACAa,GAAA,CAEA,IAAA,kBAAA9B,GACA,KAAA,IAAAsC,WAAAC,gBAMA,OAJA,gBAAArC,KACAe,EAAA,WAAAf,KAAAA,EAAAe,QAAAA,EACAa,EAAA,YAAA5B,KAAAA,EAAA4B,SAAAA,GAEA/B,SAAAC,EAAAC,GACAgB,QAAAA,EACAQ,QAAAxB,EACA6B,SAAAA,ICtBA,GAAAa,eAAA,WAEA,GAAAC,GAAAC,SAAAC,eAAA,cACAC,EAAAF,SAAAC,eAAA,aACAE,EAAAH,SAAAC,eAAA,QAEAG,EAAAD,EAAAE,wBAAAC,IAAAC,OAAAC,QACAC,GAAA,EAEAC,EAAAxD,SAAA,SAAAyD,GACAP,EAAAD,EAAAE,wBAAAC,IAAAC,OAAAC,SACA,KAEAI,EAAAf,SAAA,SAAAc,GACA,GAAAE,GAAAN,OAAAO,WACAV,GAAAS,EAAA,KAAAJ,KAAA,IACAA,GAAA,EACAP,EAAAa,WAAA,8BACAhB,EAAAgB,WAAA,iCAEA,IAGAR,QAAAS,iBAAA,SAAAN,GAGAH,OAAAS,iBAAA,SAAAJ,GAAA,MC1BAK,SAAA,WAUA,QAAAC,GAAAP,GACAA,EAAAQ,SAAAR,EAAAS,gBACAT,EAAAQ,OAAAJ,UAAAM,QAAAV,EAAAQ,OAAAJ,UAAAM,QAAAC,QAAAC,EAAA,MAEAZ,EAAAa,kBAGA,QAAAC,GAAAd,GACAA,EAAAQ,SAAAR,EAAAS,gBACAT,EAAAQ,OAAAJ,UAAAM,SAAA,2BAEAV,EAAAa,kBAnBA,GAAAE,GAAA1B,SAAA2B,cAAA,gBAEAJ,EAAA,GAAAK,QAAA,mCAAA,IAGAF,GAAAV,iBAAA,YAAAE,GAAA,GACAQ,EAAAV,iBAAA,WAAAS,GAAA,MCRAI,kBAAA,WA4CA,QAAAC,GAAAC,EAAAC,GACA,MAAAD,GAAAC,EA3CA,GAAAC,GAAAjC,SAAAkC,uBAAA,mBACAC,EAAAnC,SAAAC,eAAA,QAEAmC,KACAb,EAAA,GAAAK,QAAA,kCAAA,KACAS,EAAAF,EAAA9B,wBAAAC,IAAAC,OAAAC,QACA8B,EAAA,GAAAC,OAAAN,EAAAO,OAAA,GAAAC,KAAA,KAAAC,MAAA,IAAAC,IAAAC,YACAC,EAAAP,EAEAQ,EAAA5F,SAAA,SAAAyD,GAEA,GADA0B,EAAAF,EAAA9B,wBAAAC,IAAAC,OAAAC,QACAD,OAAAwC,WAAA,KAAA,IAAAF,EAAAG,OAAAlB,EAAA,GAAA,CACAe,EAAA,GAAAN,OAAAN,EAAAO,OAAA,GAAAC,KAAA,KAAAC,MAAA,IAAAC,IAAAC,WAEA,KAAA,GADAK,GAAAjD,SAAAkC,uBAAA,mBACAgB,EAAA,EAAAA,EAAAD,EAAAT,OAAAU,IACAD,EAAAC,GAAAnC,UAAAkC,EAAAC,GAAAnC,UAAAO,QAAAC,EAAA,OAGA,KAEA4B,EAAAtD,SAAA,SAAAc,GACA,GAAAE,GAAAN,OAAAO,WACA,IAAAP,OAAAwC,WAAA,KAAAV,EAAAxB,EAAA,IAAAgC,EAAAG,OAAAlB,EAAA,GAAA,EAAA,CACAM,EAAAG,MAAAa,KAAAnB,GAAAU,IAAA,SAAAU,GACA,MAAA3E,MAAA4E,IAAAtD,SAAAC,eAAAoD,EAAAE,IAAAlD,wBAAAC,IAAAC,OAAAC,QAAAK,IAEA,IAAAlC,GAAAD,KAAAC,IAAAZ,MAAA,KAAAqE,GACAoB,EAAApB,EAAAqB,QAAA9E,GACA+E,EAAA,OAAAF,CACA,KAAAX,EAAAW,KACAxD,SAAAC,eAAAyD,GAAA3C,WAAA,yBACA8B,EAAAW,GAAA,KAGA,IAGAjD,QAAAS,iBAAA,SAAA8B,GAGAvC,OAAAS,iBAAA,SAAAmC,GAAA","file":"bundle.js","sourcesContent":["/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = Number(wait) || 0;\n  if (typeof options === 'object') {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? Math.min(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = Date.now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function debounced() {\n    var time = Date.now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n","/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (typeof options === 'object') {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n","var heroAnimation = (function(){\n  // Cache the DOM\n  var rightHand   = document.getElementById('right-hand');\n  var leftHand    = document.getElementById('left-hand');\n  var heroSection = document.getElementById('hero');\n\n  var heroYPosition = heroSection.getBoundingClientRect().top + window.scrollY;\n  var TH            = false; // _transformHero() flag\n\n  var _getHeroPosition = debounce(function(e){\n      heroYPosition = heroSection.getBoundingClientRect().top + window.scrollY;\n    }, 200);\n\n  var _transformHero = throttle(function (e) {\n    var currentYPosition = window.pageYOffset;\n    if(heroYPosition - currentYPosition < 300 && TH === false) {\n      TH = true;\n      leftHand.className  += \" main-hero__left-hand--move\";\n      rightHand.className += \" main-hero__right-hand--move\";\n    }\n  }, 200);\n\n  //  Bind resize window event\n  window.addEventListener('resize', _getHeroPosition);\n\n  //  Bind scroll window event\n  window.addEventListener('scroll', _transformHero, false);\n})();\n","var svgHover = (function(){\n  // Cache the DOM\n  var svgUl = document.querySelector(\"#skills-grid\");\n\n  var regClassName = new RegExp('(^| )'+ 'main-skills__svg--fill' +'($| )','g');\n\n  //  Bind mouse events\n  svgUl.addEventListener(\"mouseover\", _showColor, false);\n  svgUl.addEventListener(\"mouseout\", _removeColor, false);\n\n  function _showColor(e) {\n    if(e.target !== e.currentTarget) {\n      e.target.className.baseVal = e.target.className.baseVal.replace(regClassName,' ');\n    }\n    e.stopPropagation();\n  }\n\n  function _removeColor(e) {\n    if(e.target !== e.currentTarget) {\n      e.target.className.baseVal += \" main-skills__svg--fill\";\n    }\n    e.stopPropagation();\n  }\n})();\n","var workGridAnimation = (function(){\n  // Cache the DOM\n  var workItems   = document.getElementsByClassName('main-work__item');\n  var workSection = document.getElementById('work');\n\n  var workItemsYPosition = [];\n  var regClassName       = new RegExp('(^| )'+ 'main-work__item--grow' +'($| )','g');\n  var workYPosition      = workSection.getBoundingClientRect().top + window.scrollY;\n  var zeroArr            = new Array(workItems.length+1).join('0').split('').map(parseFloat);\n  var TW                 = zeroArr; // transformWorkGrid() flag array\n\n  var _resetItensSize = debounce(function(e){\n    workYPosition = workSection.getBoundingClientRect().top + window.scrollY;\n    if (window.innerWidth < 720 && (TW.reduce(_add, 0)) !== 0) {\n      TW = new Array(workItems.length+1).join('0').split('').map(parseFloat);\n      var gridItem = document.getElementsByClassName(\"main-work__item\");\n      for(var i = 0; i < gridItem.length; i++) {\n        gridItem[i].className = gridItem[i].className.replace(regClassName,' ');\n      }\n    }\n  }, 200);\n\n  var _transformWorkGrid = throttle(function(e){\n    var currentYPosition = window.pageYOffset;\n    if (window.innerWidth < 720 && workYPosition - currentYPosition < 50 && (TW.reduce(_add, 0)) < 5) {\n      workItemsYPosition = Array.from(workItems).map(function(entry) {\n        return Math.abs(document.getElementById(entry.id).getBoundingClientRect().top + window.scrollY - currentYPosition);\n      }); // Arr with abs values of the distance between every grid item from the top of the window\n      var min = Math.min.apply(null, workItemsYPosition);\n      var divSufix = workItemsYPosition.indexOf(min);\n      var topGridItemID = 'wli-' + divSufix;\n      if (TW[divSufix] !== 1) {\n        document.getElementById(topGridItemID).className += \" main-work__item--grow\";\n        TW[divSufix] = 1;\n      }\n    }\n  }, 100);\n\n  //  Bind resize window event\n  window.addEventListener('resize', _resetItensSize);\n\n  //  Bind scroll window event\n  window.addEventListener('scroll', _transformWorkGrid, false);\n\n  function _add(a, b) {\n      return a + b;\n  }\n})();\n"]}